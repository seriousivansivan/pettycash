<script> // Companies dropdown loader (unchanged) 
let companyOptionsHTML = '<option value="">-- select company --</option>'; async function loadCompanies() { const res = await fetch('/api/companies'); const data = await res.json(); const names = data.names || []; companyOptionsHTML = '<option value="">-- select company --</option>' + names.map(n => `<option value="${n}">${n}</option>`).join(''); document.querySelectorAll('.companySel').forEach(sel => sel.innerHTML = companyOptionsHTML); } document.getElementById('refreshCompanies').addEventListener('click', (e) => { e.preventDefault(); loadCompanies(); }); const tbody = document.getElementById('rows'); 
// --------------- CATEGORY AUTOCOMPLETE (type-ahead, no dropdown) --------------- 
const CATEGORIES = [ 'Office Supplies', 'Office Equipment & Furniture', 'Technology & Electronics', 'Office Maintenance & Cleaning', 'Office Renovation & Repairs', 'Transportation', 'Office Utilities', 'Pantry & Refreshments', 'Software & Subscriptions', 'Professional Services', 'Staff Welfare & HR Expenses', 'Administrative & Legal Expenses', 'Marketing & Communication', 'Security & Safety' ]; const CAT_ITEMS = CATEGORIES.map(label => ({ label, norm: label.toLowerCase().replace(/[^a-z0-9]/g,'') })); function normalize(s) { return String(s || '').toLowerCase().replace(/[^a-z0-9]/g,''); } function findSuggestion(typed) { const n = normalize(typed); if (!n) return null; 
// First try "startsWith", then "includes" as fallback 
/let hit = CAT_ITEMS.find(it => it.norm.startsWith(n)); if (!hit) hit = CAT_ITEMS.find(it => it.norm.includes(n)); return hit ? hit.label : null; } function attachCategoryAutocomplete(input) 
{ 
    // Avoid the browser’s own autofill interfering 
    input.setAttribute('autocomplete', 'off'); input.setAttribute('autocorrect', 'off'); input.setAttribute('autocapitalize', 'off'); input.setAttribute('spellcheck', 'false'); let internal = false; function suggest() { if (internal) return; const selStart = input.selectionStart ?? input.value.length; const selEnd = input.selectionEnd ?? input.value.length;
        // Only suggest when caret is at the end or selection end equals value end if 
        (selEnd !== input.value.length) return; const userPart = input.value.slice(0, selStart); if (userPart.length < 2) return; 
        // require at least 2 chars 
        const suggestion = findSuggestion(userPart); if (!suggestion) return; 
        // Replace with suggestion and select the autocompleted tail internal = true; const prefixLen = userPart.length; input.value = suggestion; // Defer selection to next frame so browsers keep the highlight requestAnimationFrame(() => { try { input.setSelectionRange(prefixLen, suggestion.length); } catch {} internal = false; }); } input.addEventListener('input', suggest); // Accept suggestion with Tab, Enter, or Right Arrow input.addEventListener('keydown', (e) => { if (e.key === 'Tab' || e.key === 'Enter' || e.key === 'ArrowRight') { const start = input.selectionStart ?? 0; const end = input.selectionEnd ?? 0; if (end > start) { // there is a suggested tail selected — accept it e.preventDefault(); requestAnimationFrame(() => { try { input.setSelectionRange(end, end); } catch {} }); } } }); } // Attach to existing row on load function wireCategoryInputs() { document.querySelectorAll('input.cat-input').forEach(inp => { if (!inp.__acBound) { attachCategoryAutocomplete(inp); inp.__acBound = true; } }); } // Add row document.getElementById('add').addEventListener('click', (e) => { e.preventDefault(); const tr = document.createElement('tr'); tr.innerHTML = ` <td><select name="company" class="companySel" required>${companyOptionsHTML}</select></td> <td><input type="text" name="category" class="cat-input" autocomplete="off" autocapitalize="off" spellcheck="false" required></td> <td><input type="text" name="description" required></td> <td><input type="number" step="0.01" min="0" name="amount" required></td> <td><input type="text" name="payTo" required></td> <td><input type="date" name="date" required></td> <td style="text-align:center"><input type="checkbox" name="separate"></td> <td style="text-align:center"><button class="btn btn-danger remove">X</button></td> `; tbody.appendChild(tr); wireCategoryInputs(); // attach autocomplete to the new input }); tbody.addEventListener('click', (e) => { if (e.target.classList.contains('remove')) { e.preventDefault(); e.target.closest('tr').remove(); } }); function collectRows() { const rows = []; tbody.querySelectorAll('tr').forEach(tr => { const obj = { company: tr.querySelector('select[name="company"]').value, category: tr.querySelector('input[name="category"]').value, description: tr.querySelector('input[name="description"]').value, amount: tr.querySelector('input[name="amount"]').value, payTo: tr.querySelector('input[name="payTo"]').value, date: tr.querySelector('input[name="date"]').value, separate: tr.querySelector('input[name="separate"]').checked }; if (obj.company || obj.category || obj.description) rows.push(obj); }); return rows; } document.getElementById('generate').addEventListener('click', async (e) => { e.preventDefault(); const rows = collectRows(); if (rows.length === 0) return alert('Add at least one row.'); const res = await fetch('/generate', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ rows }) }); if (!res.ok) return alert('Failed to generate PDF'); const blob = await res.blob(); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'pettycash.pdf'; document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(url); }); // Initial boot loadCompanies(); wireCategoryInputs(); </script>